# Test file for testing regular expressions, we keep things to lines
# so that we don't need to worry about quotes and delimeters
#
# The format is:
#
#       /<regex>
#       <string>
#       <g0 match>          -- 0: 1,9          (start to end)
#       <g1 match>          -- 1: 4,5          (start to end)
#       <blank>             -- for no more matches
#
N:simplematch
D:match a simple three char regex
/abc
T:hereabcthere
0: 4,7

N:groupmatch
/(abc)
T:hereabcthere
0: 4,7
1: 4,7

N:simpledotstar
/.*abc
T:somenewabnotuntilabcmore
0:0,20

N:dotstar2
/.*abc\d
T:somethingabcXnotabcYthenabc1xx
0:0,28

N:dotstargreedy
/.*abc\d
T:oneabc1twoabc2threeabc3xx
0:0,23

N:dotstarlazy
/.*?abc\d
T:oneabc1twoabc2threeabc3xx
0:0,7


N:another
/(.*)(abc)(.*)
T:hereabcthere
0: 0,12
1: 0,4
2: 4,7
3: 7,12

N:greedy
/(.*)a
T:blahablahablahablah
0:0,18
1:0,17

N:lazy
/(.*?)a
T:blahablahablahablah
0:0,3
1:0,2


N:10
/^one(a+)two
T:oneaaaatwo
0: 0,10
1: 3,7

N:11
/([0-9]{2})-(\w+)
T:42-hello
0: 0,8
1: 0,2
2: 3,8

N:12
/(ab|cd)+ef
T:abcdabef
0: 0,8
1: 4,6

N:13
/^(\w+)\s+(\w+)$
T:hello world
0: 0,11
1: 0,5
2: 6,11

N:14
/([A-Za-z]+)\s+\1
T:test test
0: 0,9
1: 0,4

N:15
/(a*)(b*)(c*)
T:aaabbc
0: 0,6
1: 0,3
2: 3,5
3: 5,6

N:16
/^(.)(.)(.)\3\2\1$
T:abccba
0: 0,6
1: 0,1
2: 1,2
3: 2,3

N:largemultiline
/(a+)bc(d+)
T:asdfjahsdfljkhas dlkfjha lskjdfh alkjshd fljakshdf asdfjahsdfljkhasasdfjas D
T:asldfkjhas dlkfjh aslkjdfh aljskdhf lajkshdf lkajshd flkjahsd flkahs dlkfjh
T:asldfjha sldfjkh asldjkfh alsjkdfh lajkshdflakjshd flkaaabcdddjahsdfl hasdf
0: 207,215
1: 207,210
2: 212,215

N:whichend
/a?a?aa
T:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
0: 0,4

N:exponential
/a?a?a?a?a?a?aaaaaa
T:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
0: 0, 12

N:groupref1
/(abc)\1
T:xxxabcabcyyy
0: 3, 9
1: 3, 6

N:groupref2
/(abc)\{1}
T:xxxabcabcyyy
0: 3, 9
1: 3, 6

N:groupref3
/(abc)\g1
T:xxxabcabcyyy
0: 3, 9
1: 3, 6

N:groupref4
/(abc)\g{1}
T:xxxabcabcyyy
0: 3, 9
1: 3, 6

N:split-prio
/(a+).*(b+)
T:sfsdfsdfaaaaxxxxxxxxxxxxxbbbbxx
0: 8,29
1: 8,12
2: 28,29

N:multi1
/(abc){2,4}
T:xxxxabcabcdefdef
0: 4,10
1: 7,10

N:multi2
/(abc){2,4}
T:xxxxabcabcabcdefdef
0: 4,13
1: 10,13

N:multi3
/(abc){2,4}
T:xxxxabcabcabcabcabcdefdef
0: 4,16
1: 13,16

N:nestedgroup
/..(a(b(c(d(e(hello))))))..
T:fredabcdehellookblah
0: 2,16
1: 4,14
2: 5,14
3: 6,14
4: 7,14
5: 8,14
6: 9,14

N:greedymatch
/a+
T:xxaxxxxaaxxxxxaaaxxxxx
0: 2,3

N:hex1
/\x41
T:xxAbb
0:2,3

N:hex2
/\x5a42x
T:xxZ42xabbc
0:2,6

N:matchall1
/.*$
I:10000
GEN:random,32K
0:0,32768

N:matchall2
/(.)(.*)$
I:10000
GEN:random,32K
0:0,32768
1:0,1
2:1,32768

N:emptymatches
/(a?)+
T:hellob
0:0,0
1:0,0

N:emptymatches2
/(a?)+(b+)
T:aaahellobbb
0:8,11
1:8,8
2:8,11

N:emptymatches3
/(a?)+?(b+)
T:bbb
0:0,3
1:0,0
2:0,3

#
# This tests how a {min,max} group works with empty matches
# everyone agrees that the last match should be the empty one
# (which makes libc and re2 wrong below in my view!) but the
# other aspect is memory allocations, this kills libc, and re2.
#
N:emptymatches4
/(a?){3,16}xyz
T:aaxyzaaa
0:0,5
1:2,2

#
# This one tests where the last match is from (a?), it's either
# the second a (1,2), or an empty match at (2,2). libc and re2 do
# the former, PCRE2 does the latter.
#
# Same with + or * 
#
N:emptymatches5
/(a?)*xyz
T:aaxyzaaa
0:0,5
1:2,2

N:broken
/.*abc.*
T:sometextwithabcinthemiddle
0:0,26

#
# This one checks that a valid task isn't killed by the optimiser
# as the outcome from a multi-group match isn't known until later
#
N:taskoptimiser1
/(a+)(a+)bb\1
T:aaaabba
0:0,7
1:0,1
2:1,4

N:lee
/a+?
T:aaaaaa
0:0,1

